
% Slideshow, written by Brent Baccala, for a lecture at Catholic University
%
% A screencast of the original lecture is available on youtube:
%
% https://www.youtube.com/watch?v=JwsuAEF2FYE

\documentclass{beamer}
\usetheme{Madrid}

\title{Building a GNU/Hurd Cluster}
\author{Brent Baccala}
\institute{\tt cosine@freesoft.org}
\date{January 17, 2018}

\setbeamertemplate{footline}{}
\beamertemplatenavigationsymbolsempty

\usepackage{xcolor}
\usepackage{comment}
\usepackage{graphicx}

\usepackage{tabularx}

\usepackage{hurd}

\usepackage{tikz}
\usetikzlibrary{positioning, fit, backgrounds, arrows, trees, shapes}

\begin{document}

\begin{frame}
\titlepage
\begin{block}{Abstract}
The GNU Hurd is a UNIX-like operating system based on Mach, an
operating system kernel developed at Carnegie Mellon University and
designed to support multi-node clusters, which have become ubiquitous
in high performance computing.  This talk will highlight current
trends in cluster computing, outline the design of Mach and Hurd, and
summarize the speaker's work to realize Hurd's potential as a
POSIX-compatible operating system that can leverage the power of an
entire cluster.
\end{block}
\end{frame}

\newcommand\topfh[7]{
#1 & #2 & #3 & #4 & #6 & #7 \\
& \multicolumn{4}{l}{\hskip 1cm #5} \\
\\
}

\begin{frame}
\frametitle{Top 10 positions of the TOP500 (November 2017)}
{\tiny
\begin{tabularx}{\textwidth}{lllllll}
\bf Rank
& \bf Name
& \bf Processor
& \bf Vendor
& \bf Cores
& \bf Operating system
\\
\\
\topfh{1}
{Sunway TaihuLight}
{SW26010}
{NRCPC}
{National Supercomputing Center in Wuxi, CHN}
{10,649,600}
{Linux (Raise)}

\topfh{2}
{Tianhe-2}
{Xeon E5–2692, Xeon Phi 31S1P}
{NUDT}
{National Supercomputing Center in Guangzhou, CHN}
{3,120,000}
{Linux (Kylin)}

\topfh{3}
{Piz Daint}
{Xeon E5-2690v3, Nvidia Tesla P100}
{Cray}
{Swiss National Supercomputing Centre, SWI}
{361,760}
{Linux (CLE)}

\topfh{4}
{Gyoukou}
{Xeon D-1571, PEZY-SC2}
{ExaScaler}
{Japan Agency for Marine-Earth Science and Technology, JAP}
{19,860,000}
{Linux (CentOS)}

\topfh{5}
{Titan}
{Opteron 6274, Nvidia Tesla K20X}
{Cray}
{Oak Ridge National Laboratory, USA}
{560,640}
{Linux (CLE, SLES based)}

\topfh{6}
{Sequoia}
{IBM A2}
{IBM}
{Lawrence Livermore National Laboratory, USA}
{1,572,864}
{Linux (RHEL and CNK)}

\topfh{7}
{Trinity}
{Xeon E5–2698v3, Xeon Phi}
{Cray}
{Los Alamos National Laboratory, USA}
{979,968}
{Linux (CLE)}

\topfh{8}
{Cori}
{Xeon Phi 7250}
{Cray}
{National Energy Research Scientific Computing Center, USA}
{622,336}
{Linux (CLE)}

\topfh{9}
{Oakforest-PACS}
{Xeon Phi 7250}
{Fujitsu}
{Kashiwa, Joint Center for Advanced High Performance Computing, JPN}
{556,104}
{Linux}

\topfh{10}
{K computer}
{SPARC64 VIIIfx}
{Fujitsu}
{Riken, Advanced Institute for Computational Science (AICS), JPN}
{705,024}
{Linux}

\end{tabularx}
Source: {\tt https://www.top500.org/}
}
\end{frame}

\begin{frame}
\frametitle{Processor families in TOP500}
% https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Processor_families_in_TOP500_supercomputers.svg/800px-Processor_families_in_TOP500_supercomputers.svg.png
\includegraphics[width=\textwidth]{Processor_families_in_TOP500_supercomputers.png}
\end{frame}

\begin{frame}
\frametitle{Techniques to exploit parallelism (partial list)}
\begin{itemize}
\item Instruction level parallelism
\begin{itemize}
\item Superscalar vector operations
\end{itemize}
\item Thread level parallelism
\begin{itemize}
\item Multiple cores with shared memory
\end{itemize}
\item Co-processors
\begin{itemize}
\item More cores; simpler cores
\end{itemize}
\item Node level parallelism
\begin{itemize}
\item Multiple cores without shared memory
\item High speed LAN
\item Clusters
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers - conventional x86-64 instrs}
\begin{semiverbatim}
\tiny
int a[512];
int b[512];
int c[512];

int main () \{
  for (int i=0; i<512; i++) \{
    c[i] = a[i] + b[i];
  \}
\}


baccala@ideapad-S510p:~\$ gcc -O2 -fno-align-loops -o ex1 ex1.c


00000000004003e0 <main>:
4003e0:31 c0                xor    %eax,%eax
4003e2:8b 90 60 18 60 00    mov    0x601860(%rax),%edx
4003e8:03 90 60 10 60 00    add    0x601060(%rax),%edx
4003ee:48 83 c0 04          add    $0x4,%rax
4003f2:89 90 5c 20 60 00    mov    %edx,0x60205c(%rax)
4003f8:48 3d 00 08 00 00    cmp    $0x800,%rax
4003fe:75 e2                jne    4003e2 <main+0x2>
400400:31 c0                xor    %eax,%eax
400402:c3                   retq   

\end{semiverbatim}
\vskip 0pt plus 100fill
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers - SSE superscalar instructions}
\begin{semiverbatim}
\tiny
int a[512];
int b[512];
int c[512];

int main () \{
  for (int i=0; i<512; i++) \{
    c[i] = a[i] + b[i];
  \}
\}


baccala@ideapad-S510p:~$ gcc -O3 -fno-align-loops -o ex1 ex1.c


00000000004003e0 <main>:
4003e0:31 c0                         xor    %eax,%eax
4003e2:66 0f 6f 80 60 10 60 00       movdqa 0x601060(%rax),%xmm0
4003ea:48 83 c0 10                   add    $0x10,%rax
4003ee:66 0f fe 80 50 18 60 00       paddd  0x601850(%rax),%xmm0
4003f6:0f 29 80 50 20 60 00          movaps %xmm0,0x602050(%rax)
4003fd:48 3d 00 08 00 00             cmp    $0x800,%rax
400403:75 dd                         jne    4003e2 <main+0x2>
400405:31 c0                         xor    %eax,%eax
400407:c3                            retq   

\end{semiverbatim}
\vskip 0pt plus 100fill
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers - AVX2 superscalar instructions}
\begin{semiverbatim}
\tiny
int a[512] __attribute__((aligned(32)));
int b[512] __attribute__((aligned(32)));
int c[512] __attribute__((aligned(32)));

int main () \{
  for (int i=0; i<512; i++) \{
    c[i] = a[i] + b[i];
  \}
\}


baccala@ideapad-S510p:~$ gcc -march=native -O3 -o ex2 ex2.c


00000000004003e0 <main>:
4003e0:31 c0                         xor    %eax,%eax
4003e2:c5 fd 6f 80 60 10 60 00       vmovdqa 0x601060(%rax),%ymm0
4003ea:c5 fd fe 80 60 18 60 00       vpaddd 0x601860(%rax),%ymm0,%ymm0
4003f2:48 83 c0 20                   add    $0x20,%rax
4003f6:c5 fd 7f 80 40 20 60 00       vmovdqa %ymm0,0x602040(%rax)
4003fe:48 3d 00 08 00 00             cmp    $0x800,%rax
400404:75 dc                         jne    4003e2 <main+0x2>
400406:c5 f8 77                      vzeroupper 
400409:31 c0                         xor    %eax,%eax
40040b:c3                            retq   

\end{semiverbatim}
\vskip 0pt plus 100fill
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers - AVX512 superscalar instrs}
\begin{semiverbatim}
\tiny
int a[512] __attribute__((aligned(64)));
int b[512] __attribute__((aligned(64)));
int c[512] __attribute__((aligned(64)));

int main () \{
  for (int i=0; i<512; i++) \{
    c[i] = a[i] + b[i];
  \}
\}


baccala@ideapad-S510p:~$ gcc -mavx512vl -O3 -o ex3 ex3.c


00000000004003e0 <main>:
4003e0:31 c0                         xor    %eax,%eax
4003e2:62 f1 fd 48 6f 80 80 10 60 00 vmovdqa64 0x601080(%rax),%zmm0
4003ec:48 83 c0 40                   add    $0x40,%rax
4003f0:62 f1 7d 48 fe 80 40 18 60 00 vpaddd 0x601840(%rax),%zmm0,%zmm0
4003fa:62 f1 fd 48 7f 80 40 20 60 00 vmovdqa64 %zmm0,0x602040(%rax)
400404:48 3d 00 08 00 00             cmp    $0x800,%rax
40040a:75 d6                         jne    4003e2 <main+0x2>
40040c:31 c0                         xor    %eax,%eax
40040e:c3                            retq   

baccala@ideapad-S510p:~$ ./ex3
Illegal instruction (core dumped)
baccala@ideapad-S510p:~$ ./ex3

\end{semiverbatim}
\vskip 0pt plus 100fill
\end{frame}

\begin{frame}[fragile]
\frametitle{Pointer Aliasing}
\begin{semiverbatim}
\tiny
void operation (int * ap, int * bp, int * cp)
\{
  for (int i=0; i<16; i++) \{
    cp[i] = ap[i] + bp[i];
  \}
\}
\end{semiverbatim}
\pause
\begin{semiverbatim}
\tiny
int v[18] = \{1, 1\};

int main () \{
  operation(\&v[0], \&v[1], \&v[2]);

  for (int i=0; i<18; i++) \{
    printf("%d ", v[i]);
  \}
  printf("\\n");
\}
\end{semiverbatim}
What does this code do?
\pause
\begin{semiverbatim}
\tiny
baccala@blade6:~\$ ./ex4
1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 
baccala@blade6:~\$
\end{semiverbatim}
\end{frame}


\begin{frame}[fragile]
\frametitle{Pointer Aliasing - The {\tt restrict} keyword}
\begin{semiverbatim}
\tiny
void operation (int * restrict a, int * restrict b, int * restrict c)
\{
  for (int i=0; i<16; i++) \{
    a[i] = b[i] + c[i];
  \}
\}


gcc -mavx512vl -O3 -c ex3.c

0000000000000000 <operation>:
   0:   62 f1 7e 48 6f 06       vmovdqu32 (%rsi),%zmm0
   6:   62 f1 7d 48 fe 02       vpaddd (%rdx),%zmm0,%zmm0
   c:   62 f1 7e 48 7f 07       vmovdqu32 %zmm0,(%rdi)
  12:   c3                      retq   

\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers -- Multi-threaded Code}
\begin{semiverbatim}
\tiny
#include <thread>

int a[512], b[512], c[512];

int operation(int * ap, int * bp, int * cp, int count)
\{
  for (int i = 0; i < count; i++) \{
    cp[i] = ap[i] + bp[i];
  \}
\}

int main () \{
  const int num_threads = 3;
  int start_index[num_threads+1];
  std::thread thread[num_threads];

  start_index[0] = 0;
  for (int i=1; i < num_threads; i++) \{
    start_index[i] = i*(512/num_threads) & ~15;
  \}
  start_index[num_threads] = 512;

  for (int i=0; i < num_threads; i++) \{
    thread[i] = std::thread(operation,
                            &a[start_index[i]], &b[start_index[i]], &c[start_index[i]],
                            start_index[i+1] - start_index[i]);
  \}

  for (int i=0; i < num_threads; i++) \{
    thread[i].join();
  \}
\}
\end{semiverbatim}
\end{frame}

\begin{frame}
\frametitle{Intel Ivy Bridge Processor}
% https://www.pcper.com/files/review/2012-04-22/slides03.jpg
\includegraphics[width=\textwidth]{ivybridge.jpg}
\begin{center}
\huge
Notice the size of the graphics co-processor!
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt clDeviceQuery} on an Intel\textsuperscript{\textregistered} Core\texttrademark\ i5-4200U CPU}
\begin{semiverbatim}
\tiny
  CL_DEVICE_NAME:                       Intel(R) HD Graphics Haswell Ultrabook GT2 Mobile
  CL_DEVICE_VENDOR:                     Intel
  CL_DRIVER_VERSION:                    1.1.1
  CL_DEVICE_TYPE:                       CL_DEVICE_TYPE_GPU
  CL_DEVICE_MAX_COMPUTE_UNITS:          20
  CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS:   3
  CL_DEVICE_MAX_WORK_ITEM_SIZES:        512 / 512 / 512 
  CL_DEVICE_MAX_WORK_GROUP_SIZE:        512
  CL_DEVICE_MAX_CLOCK_FREQUENCY:        1000 MHz
  CL_DEVICE_ADDRESS_BITS:               32
  CL_DEVICE_MAX_MEM_ALLOC_SIZE:         1024 MByte
  CL_DEVICE_GLOBAL_MEM_SIZE:            2048 MByte
  CL_DEVICE_ERROR_CORRECTION_SUPPORT:   no
  CL_DEVICE_LOCAL_MEM_TYPE:             global
  CL_DEVICE_LOCAL_MEM_SIZE:             64 KByte
  CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE:   131072 KByte
  CL_DEVICE_QUEUE_PROPERTIES:           CL_QUEUE_PROFILING_ENABLE
  CL_DEVICE_IMAGE_SUPPORT:              1
  CL_DEVICE_MAX_READ_IMAGE_ARGS:        128
  CL_DEVICE_MAX_WRITE_IMAGE_ARGS:       8

  CL_DEVICE_IMAGE <dim>                 2D_MAX_WIDTH     8192
                                        2D_MAX_HEIGHT    8192
                                        3D_MAX_WIDTH     8192
                                        3D_MAX_HEIGHT    8192
                                        3D_MAX_DEPTH     2048

  CL_DEVICE_PREFERRED_VECTOR_WIDTH_<t>  CHAR 16, SHORT 8, INT 4, LONG 2, FLOAT 4, DOUBLE 0
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers -- OpenCL kernel}
\begin{semiverbatim}
\tiny
void kernel simple_add(global const int* A, global const int* B, global int* C,
                       global const int* N) \{
    int ID, Nthreads, n, ratio, start, stop;

    ID = get_global_id(0);
    Nthreads = get_global_size(0);
    n = N[0];

    ratio = (n / Nthreads);  // number of elements for each thread
    start = ratio * ID;
    stop  = ratio * (ID + 1);

    for (int i=start; i<stop; i++)
        C[i] = A[i] + B[i];
\}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Adding 512 64-bit integers -- OpenCL program}
\begin{semiverbatim}
\tiny
const int n = 512;
int A[n], B[n], C[n];

cl::Program program(context, sources);
program.build({default_device});

int N[1] = {n};

// create buffers on device (allocate space on GPU)
cl::Buffer buffer_A(context, CL_MEM_READ_WRITE, sizeof(int) * n);
cl::Buffer buffer_B(context, CL_MEM_READ_WRITE, sizeof(int) * n);
cl::Buffer buffer_C(context, CL_MEM_READ_WRITE, sizeof(int) * n);
cl::Buffer buffer_N(context, CL_MEM_READ_ONLY,  sizeof(int));

// create a queue (a queue of commands that the GPU will execute)
cl::CommandQueue queue(context, default_device);

// push write commands to queue
queue.enqueueWriteBuffer(buffer_A, CL_TRUE, 0, sizeof(int)*n, A);
queue.enqueueWriteBuffer(buffer_B, CL_TRUE, 0, sizeof(int)*n, B);
queue.enqueueWriteBuffer(buffer_N, CL_TRUE, 0, sizeof(int),   N);

cl::Kernel simple_add(program, "simple_add");
simple_add.setArg(0, buffer_A);
simple_add.setArg(1, buffer_B);
simple_add.setArg(2, buffer_C);
queue.enqueueNDRangeKernel(simple_add, cl::NullRange, cl::NDRange(20), cl::NullRange);

// read result from GPU to here
queue.enqueueReadBuffer(buffer_C, CL_TRUE, 0, sizeof(int)*n, C);

\end{semiverbatim}
\end{frame}

\begin{frame}
\frametitle{Techniques to exploit parallelism (partial list)}
\begin{itemize}
\item Instruction level parallelism
\begin{itemize}
\item Superscalar vector operations
\item \alert{Short {\tt for} loops}
\end{itemize}
\item Thread level parallelism
\begin{itemize}
\item Multiple cores with shared memory
\item \alert{Synchronization}
\end{itemize}
\item Co-processors
\begin{itemize}
\item More cores; simpler cores
\item \alert{OpenCL}
\end{itemize}
\item Node level parallelism
\begin{itemize}
\item Multiple cores without shared memory
\item High speed LAN
\item Clusters
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Cisco 5108 Blade Server Chassis with eight B200 M2s}
% https://drive.google.com/uc?export=download&id=1UVc0DbcYrSk5DNcCGneIU_RmkW83JQFA
\includegraphics[width=\textwidth]{ourcisco.jpg}
\end{frame}

\begin{frame}
\frametitle{Cluster Computing - Partial History}
\begin{itemize}
\item VMS
\item Beowulf
\begin{itemize}
\item Pioneered in 1994 at NASA
\item Message Passing Interface (MPI)
\item Parallel Virtual Machine (PVM)
\end{itemize}
\item Hadoop
\item Single System Image
\end{itemize}
\end{frame}

\begin{comment}
\begin{frame}[fragile]
\begin{semiverbatim}
\tiny
import java.io.IOException;
import java.util.StringTokenizer;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;

public class WordCount \{

  public static class TokenizerMapper
       extends Mapper<Object, Text, Text, IntWritable>\{

    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    public void map(Object key, Text value, Context context
                    ) throws IOException, InterruptedException \{
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) \{
        word.set(itr.nextToken());
        context.write(word, one);
      \}
    \}
  \}

  public static class IntSumReducer
       extends Reducer<Text,IntWritable,Text,IntWritable> \{
    private IntWritable result = new IntWritable();

    public void reduce(Text key, Iterable<IntWritable> values,
                       Context context
                       ) throws IOException, InterruptedException \{
      int sum = 0;
      for (IntWritable val : values) \{
        sum += val.get();
      \}
      result.set(sum);
      context.write(key, result);
    \}
  \}

  public static void main(String[] args) throws Exception \{
    Configuration conf = new Configuration();
    Job job = Job.getInstance(conf, ``word count'');
    job.setJarByClass(WordCount.class);
    job.setMapperClass(TokenizerMapper.class);
    job.setCombinerClass(IntSumReducer.class);
    job.setReducerClass(IntSumReducer.class);
    job.setOutputKeyClass(Text.class);
    job.setOutputValueClass(IntWritable.class);
    FileInputFormat.addInputPath(job, new Path(args[0]));
    FileOutputFormat.setOutputPath(job, new Path(args[1]));
    System.exit(job.waitForCompletion(true) ? 0 : 1);
  \}
\}
\end{semiverbatim}
\end{frame}
\end{comment}

\begin{frame}[fragile]
\frametitle{Hadoop MapReduce Tutorial - WordCount}
\begin{semiverbatim}
\tiny public class WordCount \{

  public static class TokenizerMapper
       extends Mapper<Object, Text, Text, IntWritable>\{

    private final static IntWritable one = new IntWritable(1);
    private Text word = new Text();

    public void map(Object key, Text value, Context context)
                     throws IOException, InterruptedException \{
      StringTokenizer itr = new StringTokenizer(value.toString());
      while (itr.hasMoreTokens()) \{
        word.set(itr.nextToken());
        context.write(word, one);
      \}
    \}
  \}

  public static class IntSumReducer
       extends Reducer<Text,IntWritable,Text,IntWritable> \{
    private IntWritable result = new IntWritable();

    public void reduce(Text key, Iterable<IntWritable> values, Context context)
                        throws IOException, InterruptedException \{
      int sum = 0;
      for (IntWritable val : values) \{
        sum += val.get();
      \}
      result.set(sum);
      context.write(key, result);
    \}
  \}
\}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Single System Image}
\begin{definition}
A single system image (SSI) cluster is a cluster of machines that appears to be one single system.

\hfill Wikipedia
\end{definition}
\begin{center}
\begin{tikzpicture}
\node (a) [draw] at (0:1) {};
\node (b) [draw] at (60:1) {} edge (a);
\node (c) [draw] at (120:1) {} edge (b);
\node (d) [draw] at (180:1) {} edge (c);
\node (e) [draw] at (240:1) {} edge (d);
\node (f) [draw] at (300:1) {} edge (e) edge (a);
\end{tikzpicture}
\end{center}
\begin{semiverbatim}
\$ nproc
96
\$ free -h
              total        used        free
Mem:           768G         45G        723G
Swap:            0B          0B          0B

\end{semiverbatim}
\end{frame}

\begin{frame}
\frametitle{Single System Image}

\begin{itemize}
\item Key Features
\begin{itemize}
\item Cluster-wide login
\item Single Process Space
\item Process Migration
\item Single Root Filesystem
\item Redundant Filesystem
\item Single I/O Space - block devices
\item Single IPC Space
standard Linux inter-process communication mechanisms, shared memory, semaphores, SYSV message queues, pipes and Unix domain sockets.
\item Cluster-wide IP Addresses
\end{itemize}
\item Advantages
\begin{itemize}
\item familiar programming and management tools
\item ease of leveraging additional computing power
\end{itemize}
\item Disadvantages
\begin{itemize}
\item less fault isolation
\item node failure more difficult to handle
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{POSIX System System Image -- Partial History}
\begin{itemize}
\item Single System Image Linux
\begin{itemize}
\item MOSIX
\begin{itemize}
\item Developed at Hebrew University at Jerusalem since 1977
\item Closed source; free download
\item Latest version works with Linux 4.12.13; released in 2017
\end{itemize}
\item OpenMosix
\begin{itemize}
\item Forked from last free version of MOSIX in 2001
\item Last development release 2006 (based on Linux 2.6.15)
\item Last stable release 2004 (based on Linux 2.4.26; 38,794 line diff)
\item project terminated in 2008
\end{itemize}
\item Kerrighed
\begin{itemize}
\item {\it Institut national de recherche en informatique et en automatique}
\item Latest version (3.0.0) released on 14 June 2010
\item Based on Linux 2.6.30
\end{itemize}
\item OpenSSI
\begin{itemize}
\item Funded by SCO; Compaq
\item Last development release 2010 (based on Linux 2.6.12)
\item Last stable release 2007 (based on Linux 2.6.11)
\end{itemize}
\end{itemize}
\item ScaleMP
% \item CMU Mach / GNU Hurd
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{CMU Mach / GNU Hurd}
\begin{itemize}
\item{CMU Mach}
\begin{itemize}
\item Developed at Carnegie Mellon University from 1985 to 1994
\item Pioneered the Microkernel concept
\item Kernel does Tasks / Threads / IPC / Memory Management
\item Everything else in user space (device drivers; filesystem; networking)
\item Designed for multi-node clusters
\end{itemize}
\item{GNU Hurd}
\begin{itemize}
\item Under development since 1990
\item Runs on top of Mach and implements a full POSIX system
\item Averages about two releases per year
\item Available as part of Debian
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{How many Debian packages build on Hurd?}
% https://buildd.debian.org/stats/graph-big.png
\includegraphics[width=\textwidth]{graph-big.png}
\end{frame}

\begin{frame}
\frametitle{Ports - Mach's Interprocess Communication (IPC)}

\begin{center}

% node distance is the distance that the queues are positioned from their task ports
\begin{tikzpicture}[transform canvas={scale=0.4, yshift=12em, xshift=-15em}, node distance=6em]

\task{Task 1 left}{at (0,0)}{ru}{}
\task{Task 2 left}{at (0,-11em)}{ru}{}
\task{Task 3 left}{at (0,-22em)}{ru}{}
\task{Task 4 left}{at (0,-33 em)}{ru}{}
\task{Task 1 right}{at (30 em,0)}{lu}{}
\task{Task 2 right}{at (30 em,-11 em)}{lu}{}
\task{Task 3 right}{at (30 em,-22 em)}{lu}{}
\task{Task 4 right}{at (30 em,-33 em)}{lu}{}

\queue[left = of Task 1 right Port 5]{queue 1}{}
\queue[left = of Task 2 right Port -5]{queue 2a}{}
\queue[left = of Task 2 right Port 5]{queue 2b}{}
\queue[left = of Task 3 right Port 0]{queue 3}{}
\queue[left = of Task 4 right Port 0]{queue 4}{}

\draw [color=violet, thick, -triangle 90] (Task 1 left Port 5) -- (queue 1.west);
\draw [color=violet, thick, -triangle 90] (queue 1.east) -- (Task 1 right Port 5);
\draw [color=violet, thick] (Task 2 left Port 0) -- +(1,0) |- (queue 1.west);
\draw [color=violet, thick, -triangle 90] (Task 2 left Port -3) -- +(1,0) |- (queue 4.west);

\draw [color=violet, thick, -triangle 90] (Task 2 left Port 5) -- (queue 2b.west);
\draw [color=violet, thick, triangle 90-] (Task 2 left Port -5) -- (queue 2a.west);
\draw [color=violet, thick, -triangle 90] (queue 2b.east) -- (Task 2 right Port 5);
\draw [color=violet, thick, triangle 90-] (queue 2a.east) -- (Task 2 right Port -5);

\draw [color=violet, thick, -triangle 90] (Task 3 left Port 0) -- (queue 3.west);
\draw [color=violet, thick, -triangle 90] (queue 3.east) -- (Task 3 right Port 0);

\draw [color=violet, thick, -triangle 90] (Task 3 right Port 0) ++(-1,0) |- ++(-4,1) -- ++(0,-1);

\draw [color=violet, thick, -triangle 90] (queue 4.east) -- (Task 4 right Port 0);

\draw [color=violet, thick, -triangle 90] (Task 4 left Port 3) -- +(2,0) |- +(6,5.5) |- (queue 2a.east);


\end{tikzpicture}
\end{center}

\end{frame}

\tikzstyle{message} = [draw, fill=red!20, text width=5em, text depth=3em, text centered,
  minimum width=5em, minimum height=2em, rounded corners]

\begin{frame}
\frametitle{Mach IPC}

\begin{center}

\begin{tikzpicture}

\task{Task 1}{at (0,0)}{r}{
\node (message1) [message] {Message 1};
}
\task{Task 2}{at (15 em,0)}{l}{
\node (message2) [message] at (1 em, 1 em) {Message 1};
\node (message2a) [message] at (1.9 em, -1 em) {Message 2};
}
\task{Task 3}{at (0,-11 em)}{r}{
\node (message3) [message] {Message 2};
}


\draw [color=violet, thick, ->] (node cs:name=message1,angle=20) -- +(.3,0) |- (Task 1 Port 5) node [midway, anchor=south, color=black] {27} -- (Task 2 Port 5)
    -- +(.5,0) node [at end, anchor=south, color=black] {52} |- (node cs:name=message2, angle=160);

\draw [color=violet, thick, ->] (node cs:name=message3,angle=0) -- +(.3,0) |- (Task 3 Port 0) node [midway, anchor=south, color=black] {18} -- +(1,0) |- (Task 2 Port 5)
    -- +(.5,0) |- (node cs:name=message2a, angle=160);

\end{tikzpicture}
\end{center}

\end{frame}

\begin{frame}
\frametitle{Transfering a Send Right}
\begin{center}
\begin{tikzpicture}[node distance = .5cm]

\task{Task 1}{at (0,0)}{br}{
% print two sendright nodes, one to fill the message1 box to the correct size,
% and another one to actually draw it, since message1 will overwrite the
% first sendright
\only<2->{
\node (sendright) [draw, fill=orange] {Send 41};
\node (message1) [fit=(sendright), message] {Message 1};
\node (sendright) [draw, fill=orange] {Send 41};
}

\only<4->{\node (message3) at (0, -7em) [message] {Message 2};}
}

\task{Task 2}{at (15 em,0)}{bl}{
\only<3->{
\node (sendright2) [draw, fill=orange] {Send 9};
\node (message2) [fit=(sendright2), message] {Message 1};
\node (sendright2) [draw, fill=orange] {Send 9};
}

\only<4->{\node (message4) at (0, -7em) [message] {Message 2};}
}

\only<2->{\node (port 41) [left of=Task 1 Port -10, anchor=south] {41};}

\only<2->{\draw [thick, color=red, dotted, ->] (node cs:name=sendright, angle=-20) -- (port 41);}

\node [left of=Task 1 Port 5, anchor=south] {27};
\node [right of=Task 2 Port 5, anchor=south] {52};
\only<1,2>{\draw [thick, -triangle 90] (Task 1 Port 5) -- (Task 2 Port 5);}

\only<3->{
\draw [color=violet, thick, -triangle 90] (node cs:name=message1,angle=20) -- +(.3,0) |- (Task 1 Port 5) -- (Task 2 Port 5)
    -- +(.5,0) |- (node cs:name=message2, angle=160);
}

\only<3->{\node [right of=Task 2 Port -10, anchor=south] {9};}

\only<3>{\draw [thick, triangle 90-] (Task 1 Port -10) -- (Task 2 Port -10);}

\only<4->{
\draw [color=violet, thick, triangle 90-] (node cs:name=message3,angle=20) -- +(.3,0) |- (Task 1 Port -10) -- (Task 2 Port -10)
    -- +(.5,0) |- (node cs:name=message4, angle=160);
}

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Transfering a Receive Right}
\begin{center}
\begin{tikzpicture}[node distance = .5cm]

\task{Task 1}{at (0,0)}{br}{
% print two sendright nodes, one to fill the message1 box to the correct size,
% and another one to actually draw it, since message1 will overwrite the
% first sendright
\only<2->{
\node (sendright) [draw, fill=green] {Recv 41};
\node (message1) [fit=(sendright), message] {Message 1};
\node (sendright) [draw, fill=green] {Recv 41};
}

\only<4->{\node (message3) at (0, -7em) [message] {Message 2};}
}

\task{Task 2}{at (15 em,0)}{bl}{
\only<3->{
\node (sendright2) [draw, fill=green] {Recv 9};
\node (message2) [fit=(sendright2), message] {Message 1};
\node (sendright2) [draw, fill=green] {Recv 9};
}

\only<4->{\node (message4) at (0, -7em) [message] {Message 2};}
}

\only<2->{\node (port 41) [left of=Task 1 Port -10, anchor=south] {41};}

\only<2->{\draw [thick, color=red, dotted, ->] (node cs:name=sendright, angle=-20) -- (port 41);}

\node [left of=Task 1 Port 5, anchor=south] {27};
\node [right of=Task 2 Port 5, anchor=south] {52};
\only<1,2>{\draw [thick, -triangle 90] (Task 1 Port 5) -- (Task 2 Port 5);}

\only<3->{
\draw [color=violet, thick, -triangle 90] (node cs:name=message1,angle=20) -- +(.3,0) |- (Task 1 Port 5) -- (Task 2 Port 5)
    -- +(.5,0) |- (node cs:name=message2, angle=160);
}

\only<3->{\node [right of=Task 2 Port -10, anchor=south] {9};}

\only<3>{\draw [thick, -triangle 90] (Task 1 Port -10) -- (Task 2 Port -10);}

\only<4->{
\draw [color=violet, thick, -triangle 90] (node cs:name=message3,angle=20) -- +(.3,0) |- (Task 1 Port -10) -- (Task 2 Port -10)
    -- +(.5,0) |- (node cs:name=message4, angle=160);
}

\end{tikzpicture}
\end{center}
\end{frame}


\begin{frame}
\frametitle{Memory Transfers}
\begin{center}

\begin{tikzpicture}[node distance = .5cm]

\task{Task 1}{at (0,0)}{br}{
% print two sendright nodes, one to fill the message1 box to the correct size,
% and another one to actually draw it, since message1 will overwrite the
% first sendright
\node (message1) [message] {Message};
\only<1>{
\node (memory1) [below=1em, fill=orange!40, minimum size=2cm, dashed, thick, draw] at (message1.south) {Memory};
\draw [thick, color=red, dotted, -] (message1) -- (memory1);
}
}

\task{Task 2}{at (15 em,0)}{bl}{
\only<2->{
\node (message2) [message] {Message};
\node (memory2) [below=1em, fill=orange!40, minimum size=2cm, dashed, thick, draw] at (message2.south) {Memory};
\draw [thick, color=red, dotted, -] (message2) -- (memory2);
}
}

%\node [left of=Task 1 Port 5, anchor=south] {27};
%\node [right of=Task 2 Port 5, anchor=south] {52};

%\only<1>{\draw [thick, -triangle 90] (Task 1 Port 5) -- (Task 2 Port 5);}

\only<2>{
\draw [color=violet, thick, -triangle 90] (node cs:name=message1,angle=20) -- +(.3,0) |- (Task 1 Port 5) -- (Task 2 Port 5)
    -- +(.5,0) |- (node cs:name=message2, angle=160);
}
\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Hurd Filesystem}
\tikzstyle{dirent}=[draw=black,thick,anchor=west]
\tikzstyle{selected}=[draw=red,fill=red!30]
\tikzstyle{optional}=[dashed,fill=gray!50]
\tikzstyle{link}=[red,dotted,->,thick]
\tikzstyle{grow2}=[grow via three points={one child at (1.5,0) and two children at (1.5,0) and (1.5,-0.7)},
  edge from parent path={(\tikzparentnode.east) -- +(.5,0) |- (\tikzchildnode.west)}]
\begin{center}
\begin{tikzpicture}
  [node distance = 1em, grow via three points={one child at (0.5,-0.7) and
  two children at (0.5,-0.7) and (0.5,-1.4)},
  edge from parent path={(\tikzparentnode.south) |- (\tikzchildnode.west)}]
  \node[dirent] (root) {/}
  child { node[dirent] {bin}
    child [grow2] { node[dirent] (bash) {bash}}
    child [grow2] { node[dirent] (date) {date}}
    child [grow2] { node[dirent] (grep) {grep}}
    child [grow2] { node[dirent] (ls) {ls}}
  }
  child { node[dirent] {etc}}
  child { node[dirent] {lib}}
  child { node[dirent] {tmp}}
  child { node[dirent] (hurd) {hurd}}
  child { node[dirent] (home) {home}}
  child { node[dirent] (http) {http:}}
  child { node[dirent] {servers}
    child { node[dirent] {socket}
      child { node[dirent] (inet) {inet}}
    }
  };


\task{ext2 File Server}{at (20 em,-5 em)}{l}{}
\task [below = of ext2 File Server] {httpfs}{}{ls}{}
\task [below = of httpfs] {pfinet}{}{ls}{}

\draw [link] (root) -- +(5,0) |- (ext2 File Server Port 7);
\draw [link] (bash) -- +(1,0) |- (ext2 File Server Port 5);
\draw [link] (date) -- +(1,0) |- (ext2 File Server Port 3);
\draw [link] (grep) -- +(1.5,0) |- (ext2 File Server Port 1);
\draw [link] (ls) -- +(2,0) |- (ext2 File Server Port -1);
\draw [link] (hurd) -- +(2,0) -- (ext2 File Server Port -3);
\draw [link] (home) -- +(3,0) -- (ext2 File Server Port -5);

\draw [link] (http) -- (httpfs Port 1);
\draw [link] (inet) -- (pfinet Port -1);

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt rpctrace} of {\tt ls} (9 of 144 RPCs)}
\begin{semiverbatim}
\tiny
task135(pid9403)->task_get_special_port (4) = 0    143(pid9403)

  143(pid9403)->exec_startup_get_info () = 0 134526367 134512692 288 188416 16777216 0 "ls\\0"
        "LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd"
        \{  140(pid9403)   145(pid9403)   146(pid9403)   147(pid9403)\}
        \{  148(pid9403)   149(pid9403)   150(pid9403)   151(pid9403)   152(pid9403) (null)\}
        \{18 0 0 0 0\}

/* Standard port assignments for file_exec_file_name and exec_* */
enum
  \{
    INIT_PORT_CWDIR,
    INIT_PORT_CRDIR,
    INIT_PORT_AUTH,
    INIT_PORT_PROC,
    INIT_PORT_CTTYID,
    INIT_PORT_BOOTSTRAP,
  \};

  145(pid9403)->term_open_ctty (9403 9402) = 0    138(pid9403)

  148(pid9403)->dir_lookup ("./" 2097161 0) = 0 1 "    166(pid9403)

  166(pid9403)->dir_readdir (0 -1 0) = 0 "\\x01\\x9c\\x01\\0\\0\\0\\0\\0\\x10\\0\\0\\x01.\\0\\0\\0P\\xd7\\0\\0\\0\\0\\0\\0\\x10\\0\\0\\x02..\\0\\0\\x03\\x9c\\x01\\0\\0\\0\\0\\0\\x14\\0\\0\\x04.git\\0\\0\\0\\0\\x90_\\a\\0\\0\\0\\0\\0\\x18\\0\\0\\blibpager\\0\\0\\0\\0c\\x9a\\x01\\0" 10

  166(pid9403)->dir_readdir (10 -1 0) = 0 " 0

  145(pid9403)->io_stat () = 0 {14 969 0 0 0 1458877724 0 8397184 1 0 5 0 0 1515530623 0 1515530623 0 1515530623 0 512 8 0 0 0 0 0 1103856 1038 1163584 1039 0 0}

  138(pid9403)->io_write ("junk  libpager machMessage.h  netmsg  papers  patches README.md\\n" -1) = 0 64

task135(pid9403)->task_terminate () = 0 
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt rpctrace} of {\tt ls} (mapping the C library)}
\begin{semiverbatim}
\tiny
  149(pid9403)->dir_lookup ("lib/i386-gnu/libc.so.0.3" 1 0) = 0 1 ""    155(pid9403)

  155(pid9403)->io_read (-1 512) = 0 "\\x7fELF\\x01\\x01\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\0\\x03\\0\\x03\\0\\x01\\0\\0\\0pE\\x05\\04\\0\\0\\0\\xfc\\x19''\\0\\0\\0\\0\\04\\0 \\0\\n\\0(\\0x\\0w\\0\\x06\\0\\0\\04\\0\\0\\04\\0\\0\\04\\0\\0\\0@\\x01\\0\\0@\\x01\\0\\0\\x05\\0\\0\\0"

  155(pid9403)->io_stat () = 0 {23 5 0 158020 0 1513754748 0 33261 1 0 0 2239676 0 1515530623 0 1513435063 0 1513747658 0 8192 4384 0 0 0 0 0 0 0 0 0 0 0}

  155(pid9403)->io_map () = 0    153(pid9403)  (null)

task135(pid9403)->vm_map (0 2245448 0 1    153(pid9403) 0 32 5 7 1) = 0 17039360


\end{semiverbatim}
\end{frame}

\tikzstyle{kernel} = [draw, fill=blue!20, rounded corners, minimum width=30em, minimum height=8em]

\begin{frame}
\frametitle{Mach Memory Management}
\begin{center}
\begin{tikzpicture}

\task{Filesystem Server}{at (0,0)}{}{
\node (memory1) [above left=-0.5, fill=white, minimum size=1.5cm, dashed, thick, draw] {};
}
\task{ls}{at (15 em,0)}{}{
%\node (memory1) [above right=-0.5, fill=orange!40, minimum size=1.5cm, dashed, thick, draw] {};
\node (memory2) [above right=-0.5, fill=white, minimum size=1.5cm, dashed, thick, draw] {};
\node [below] at (memory2.north) {\tiny addr};
}

\node (kernel) [kernel] at (7.5 em, -10 em) {};
\node (kmemory) [fill=white, minimum size=1.5cm, dashed, thick, draw] at (7.5 em, -10 em) {};
\node [below] at (kernel.north) {Kernel};

\draw [color=red, <-, thick] (2 em,1) -- node [midway, above] {io\_map} (13 em,1);
\draw [color=red, ->, thick, dotted] (2 em,.9) -- node [midway, below] {\tiny port 153} (13 em,.9);

\draw [color=red, ->, thick] (15 em,-3 em) -- node [midway, left] {vm\_map} (15 em,- 8 em);
\draw [color=red, <-, thick, dotted] (15.2 em,-3 em) -- node [midway, right] {\tiny addr} (15.2 em,- 8 em);

\only<1>{
  \draw [color=red, <-, thick] (-2 em,-3 em) -- node [midway, left] {m\_o\_init} (-2 em,- 8 em);
  \draw [color=red, ->, thick] (-1.5 em,-3 em) -- node [midway, right] {m\_o\_ready} (-1.5 em,- 8 em);
}
\only<2>{
  \draw [color=red, <-, thick] (0.5 em,-3 em) -- node [midway, left] {m\_o\_data\_request} (0.5 em,- 8 em);
  \draw [color=red, ->, thick] (1 em,-3 em) -- node [midway, right] {m\_o\_data\_supply} (1 em,- 8 em);
}

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}
\frametitle{Mach Memory Management: Shared Memory}
%\begin{center}
\begin{tikzpicture}[transform canvas={xshift=9.5em, yshift=2em}]

\task{Task 1}{at (-5em,0)}{}{
\node (memory1) [fill=orange!40, minimum size=1.5cm, dashed, thick, draw] {};
}
\task{Task 2}{at (6 em,0)}{}{
\node (memory2) [fill=orange!40, minimum size=1.5cm, dashed, thick, draw] {};
}
\task{Task 3}{at (17 em,0)}{}{
\node (memory3) [fill=orange!40, minimum size=1.5cm, dashed, thick, draw] {};
}

\node (kernel) [kernel] at (6 em, -10 em) {};
\node (kmemory) [fill=orange!40, minimum size=1.5cm, thick, draw] at (6 em, -10 em) {};
\node [below] at (kernel.north) {Kernel};

\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory1);
\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory2);
\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory3);


\end{tikzpicture}
%\end{center}
\end{frame}

\begin{frame}
\frametitle{Mach Memory Management: Distributed Shared Memory}

\tikzstyle{emptymemory} = [fill=white, minimum size=1.5cm, dashed, thick, draw]
\tikzstyle{readmemory} = [fill=orange!40, minimum size=1.5cm, thick, draw]
\tikzstyle{writememory} = [fill=green!40, minimum size=1.5cm, thick, draw]

\begin{tikzpicture}[transform canvas={xshift=12em, yshift=7em, scale=0.4}]

\task{Task 1}{at (-5em,0)}{u}{
\only<1-2,9->{\node (memory1) [emptymemory] {\only<2>{\Huge R}};}
\only<3-8> {\node (memory1) [readmemory, dashed] {};}
}
\task{Task 2}{at (6 em,0)}{u}{
\only<1-3,9->{\node (memory2) [emptymemory] {};}
\only<4-8>{\node (memory2) [readmemory, dashed] {};}
}
\task{Task 3}{at (17 em,0)}{u}{
\only<1-3,9-13>{\node (memory3) [emptymemory] {\only<11->{\Huge W}};}
\only<4-8>{\node (memory3) [readmemory, dashed] {};}
\only<14->{\node (memory3) [writememory, dashed] {};}
}

\node (kernel) [kernel] at (6 em, -10 em) {};
\only<1-2,9-13>{\node (kmemory) [fill=white, minimum size=1.5cm, dashed, thick, draw] at (6 em, -10 em) {};}
\only<3-8>{\node (kmemory) [fill=orange!40, minimum size=1.5cm, thick, draw] at (6 em, -10 em) {};}
\only<14>{\node (kmemory) [writememory] at (6 em, -10 em) {};}
\node [below] at (kernel.north) {Kernel};

\only<3-8>{\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory1);}
\only<4-8>{\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory2);}
\only<4-8>{\draw [orange, ultra thick, dotted, ->] (kmemory) -- (memory3);}
\only<14->{\draw [green, ultra thick, dotted, ->] (kmemory) -- (memory3);}

\node (server) [kernel, color=cyan!20, minimum width=20em] at (6 em, -20 em) {};
\only<1-9>{\node (smemory) [readmemory] at (server) {};}
\only<10-12,14>{\node (smemory) [emptymemory] at (server) {};}
\only<13>{\node (smemory) [writememory] at (server) {};}
\node [below] at (server.north) {Memory Object Server};

\only<2>{\draw [red, ->] (kernel) -- node [midway, left] {\huge m\_o\_data\_request} (server);}
\only<3>{\draw [red, <-] (kernel) -- node [midway, right] {\huge m\_o\_data\_supply} (server);}
\only<8>{\draw [red, <-] (kernel) -- node [midway, right] {\huge m\_o\_lock\_request (flush)} (server);}
\only<9>{\draw [red, ->] (kernel) -- node [midway, right] {\huge m\_o\_lock\_completed} (server);}
\only<11>{\draw [red, ->] (kernel) -- node [midway, left] {\huge m\_o\_data\_request} (server);}
\only<14>{\draw [red, <-] (kernel) -- node [midway, right] {\huge m\_o\_data\_supply} (server);}

\node (kernel2) [kernel] at (6 em, -30 em) {};
\only<1-5,13->{\node (kmemory2) [emptymemory] at (kernel2) {};}
\only<6-9>{\node (kmemory2) [readmemory] at (kernel2) {};}
\only<10-12>{\node (kmemory2) [writememory] at (kernel2) {};}
\node [below] at (kernel2.north) {Kernel};

\task{Task 4}{at (-5em,-40 em)}{u}{
\node (memory4) [emptymemory] {};
}
\task{Task 5}{at (6 em,-40 em)}{u}{
\only<1-5,13->{\node (memory5) [emptymemory] {\only<5>{\Huge R}};}
\only<6-12>{\node (memory5) [readmemory, dashed] {};}
}
\task{Task 6}{at (17 em,-40 em)}{u}{
\only<1-9,13->{\node (memory6) [emptymemory] {\only<7-9>{\Huge W}};}
\only<10-12>{\node (memory6) [writememory, dashed] {};}
}

\only<5>{\draw [red, ->] (kernel2) -- node [midway, left] {\huge m\_o\_data\_request} (server);}
\only<6>{\draw [red, <-] (kernel2) -- node [midway, right] {\huge m\_o\_data\_supply} (server);}
\only<7>{\draw [red, ->] (kernel2) -- node [midway, left] {\huge m\_o\_data\_unlock} (server);}
\only<10>{\draw [red, <-] (kernel2) -- node [midway, right] {\huge m\_o\_lock\_request (+write)} (server);}
\only<12>{\draw [red, <-] (kernel2) -- node [midway, right] {\huge m\_o\_lock\_request (flush)} (server);}
\only<13>{\draw [red, ->] (kernel2) -- node [midway, left] {\huge m\_o\_data\_return} (server);}

\only<6-12>{\draw [orange, ultra thick, dotted, ->] (kmemory2) -- (memory5);}
\only<10-12>{\draw [green, ultra thick, dotted, ->] (kmemory2) -- (memory6);}

\end{tikzpicture}
\end{frame}

\begin{frame}
\frametitle{The {\tt netmsg} Server}
\begin{tikzpicture}[transform canvas={xshift=12em, yshift=6em, scale=0.4}]

\task{Task 1}{at (-5em,0)}{u}{}
\task{Task 2}{at (6 em,0)}{u}{}
\task{Task 3}{at (17 em,0)}{u}{}

\node (kernel) [kernel] at (6 em, -10 em) {};
\node [above of=kernel] {\Huge netmsg};

\node [cloud, draw,cloud puffs=10,cloud puff arc=120, aspect=2, inner ysep=1em, minimum width=20em, minimum height=10em]
  at (6 em, -20 em) {};

\node (kernel2) [kernel] at (6 em, -30 em) {};
\node [above of=kernel2] {\Huge netmsg};

\task{Task 4}{at (-5em,-40 em)}{u}{}
\task{Task 5}{at (6 em,-40 em)}{u}{}
\task{Task 6}{at (17 em,-40 em)}{u}{}

\draw [red] (Task 1.south) -- (kernel.center) -- (kernel2.center) -- (Task 4.north);
\draw [red] (Task 2.south) -- (kernel.center) -- (kernel2.center) -- (Task 5.north);
\draw [red] (Task 3.south) -- (kernel.center) -- (kernel2.center) -- (Task 6.north);

\end{tikzpicture}
\end{frame}

\begin{frame}
\frametitle{The {\tt netmsg} Server}
\begin{itemize}
\item All Mach messages serialized over a single TCP connection
\item Transmit Mach messages (almost) unchanged
\item Memory regions are appended at the end of the message
\item Local port numbers are transmitted unchanged
\item Remote port numbers have all their bits inverted
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{The {\tt netmsg} Server}
\begin{center}
\begin{tikzpicture}[transform canvas={xshift=0em, yshift=-3em, scale=0.4}]

\fill[color=yellow!20] (-50 em, -10 em) rectangle (-8 em, 25 em);
\node at (-21 em, 20em) {\Huge Node 1};
\fill[color=yellow!20] (50 em, -10 em) rectangle (8 em, 25 em);
\node at (21 em, 20em) {\Huge Node 2};

\filldraw (-30 em, 15em) node[rectangle, name=queue 1, minimum width=1.8cm, minimum height=1cm, draw, pattern=vertical lines] {};

\task{Task 1}{at (-30 em,0)}{r}{
  \only<1-2>{
    \node (sendright) [draw, fill=orange, inner xsep=5] {Send};
    \node (message1) [fit=(sendright), message] {Message};
    \only<1>{\node (sendright) [draw, fill=orange, inner xsep=5] {Send};}
  }
}
\task{netmsg 1}{at (-15 em,0)}{l}{
  \only<2-3>{
    \node (sendright2) [draw, fill=orange, inner xsep=5] {Send};
    \node (message2) [fit=(sendright2), message] {Message};
  }
  \only<2->{\node (sendright2) [draw, fill=orange, inner xsep=5] {Send};}
}

\only<1>{\draw[red,dotted,->,ultra thick] (sendright) -- (queue 1);}
\only<2>{\draw[ultra thick,->] (message1) -- (message2);}
\only<2->{
  \draw[red,dotted,->,ultra thick] (sendright2) -- (queue 1);
}

\node [cloud, draw,cloud puffs=10,cloud puff arc=120, aspect=2, inner ysep=1em, minimum width=15em, minimum height=8em]
  at (0 em, 0 em) {};

\only<4->{
  \filldraw (15 em, 15em) node[rectangle, name=queue 2, minimum width=1.8cm, minimum height=1cm, draw, pattern=vertical lines] {};
}

\task{netmsg 2}{at (15 em,0)}{r}{
  \only<3-5>{
    \node (sendright3) [draw, fill=orange, inner xsep=5] {Send};
    \node (message3) [fit=(sendright3), message] {Message};
    \only<4>{\node (sendright3) [draw, fill=orange, inner xsep=5] {Send};}
  }
  \only<4->{\node (rcvright3) [draw, fill=green, inner xsep=5] at (0,1.25) {Rcv};}
}
\task{Task 2}{at (30 em,0)}{l}{
  \only<5>{
    \node (sendright4) [draw, fill=orange, inner xsep=5] {Send};
    \node (message4) [fit=(sendright4), message] {Message};
  }
  \only<5-6>{\node (sendright4) [draw, fill=orange, inner xsep=5] {Send};}
}

\only<1>{\draw[ultra thick, dotted, ->] (Task 1) -- (Task 2);}

\only<3>{\draw[ultra thick,->] (message2) -- (message3);}

\only<4>{\draw[red,dotted,->,ultra thick] (sendright3.west) to [bend left=20] (queue 2);}
\only<4->{\draw[green,dotted,->,ultra thick] (queue 2) -- (rcvright3);}

\only<5->{

\draw[red,dotted,->,ultra thick] (sendright4) -- (queue 2);
}

\only<5>{\draw[ultra thick,->] (message3) -- (message4);}

\end{tikzpicture}
\end{center}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt netmsg}: Translation of a send right for transmission}
\begin{semiverbatim}
\tiny
if ((ports[i] == MACH_PORT_NULL) || (ports[i] == MACH_PORT_DEAD))
  \{
    continue;
  \}
else if (remote_ports_by_local.count(ports[i]) == 1)
  \{
    /* We're transmitting a send right that we earlier received over the network.  Convert to the
     * remote's name space, and indicate to the remote, by bit flipping the port number, that we're
     * sending it a port number in its own name space.  Also, destroy the send right we received
     * with the message, which is a send right to ourself!  If it's the port's last send right, then
     * we'll get a no senders notification and deallocate the receive right then, so all we destroy
     * here is the send right.
     */

    assert(local_port_type.at(ports[i]) == MACH_MSG_TYPE_PORT_RECEIVE);
    mach_call (mach_port_mod_refs (mach_task_self(), ports[i],
                                   MACH_PORT_RIGHT_SEND, -1));

    ports[i] = (~ remote_ports_by_local[ports[i]]);
  \}
else
  \{
    /* We've got a send right (note it), but no mapping to a remote port (the remote takes care of that) */

    local_port_type[ports[i]] = MACH_MSG_TYPE_PORT_SEND;

    /* request a DEAD NAME notification */

    mach_call (mach_port_request_notification (mach_task_self (), ports[i],
                                               MACH_NOTIFY_DEAD_NAME, 0,
                                               notification_port, MACH_MSG_TYPE_MAKE_SEND_ONCE, &old));
  \}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt netmsg}: Translation of a send right on reception}
\begin{semiverbatim}
\tiny
/* We're receiving a send right over the network.  We need to relay on a send
 * right, which will be to a local receive right.
 */

if (local_ports_by_remote.count(port) == 1)
  \{
    const mach_port_t newport = local_ports_by_remote[port];

    assert(local_port_type.at(newport) == MACH_MSG_TYPE_PORT_RECEIVE);

    /* it already exists; create a new send right to relay on */
    mach_call (mach_port_insert_right (mach_task_self (), newport, newport,
                                       MACH_MSG_TYPE_MAKE_SEND));

    return newport;
  \}
else
  \{
    mach_port_t newport;

    /* create new receive port and a new send right that will be moved to the recipient */
    mach_call (mach_port_allocate (mach_task_self (), MACH_PORT_RIGHT_RECEIVE, &newport));
    mach_call (mach_port_insert_right (mach_task_self (), newport, newport,
                                       MACH_MSG_TYPE_MAKE_SEND));

    /* request notification when all send rights have been destroyed */
    mach_port_t old;
    mach_call (mach_port_request_notification (mach_task_self (), newport,
                                               MACH_NOTIFY_NO_SENDERS, 0,
                                               newport, MACH_MSG_TYPE_MAKE_SEND_ONCE, &old));
    return newport;
  \}
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Pseudocode: {\tt memory\_object\_data\_request}}
\begin{semiverbatim}
\tiny
memory_object_data_request: (kernel requesting a single page)

  if TERMINATING flag set, return
  if this client is on NEXTERROR list and WRITE ACCESS WAS REQUESTED, send a m_o_data_error message,
        move NEXTERROR to ERROR, remove the NEXTERROR list entry, and return
  if the page is PAGINGOUT:
    if WAITLIST is empty and ACCESSLIST is not, send lock request (internal flush) to ACCESSLIST client
       ASSERT: there should only be one WRITE client on ACCESSLIST
               (the client that returned the data we're paging out)
    add requesting client to WAITLIST and return
  if this client is already on ACCESSLIST, it flushed and is trying to re-aquire access,
     so check to see if WAITLIST is empty
     if so, remove client from ACCESSLIST and proceed (kernel flushed without being asked)
     if not, we're flushing, so add client to WAITLIST, run internal_lock_completed on this page, and return
  if WAITLIST is not empty, add requesting client to WAITLIST and return
  if another client has WRITE access (WAITLIST is empty), add requesting client to WAITLIST,
     send lock request (internal flush variant) and return
  if WRITE access is requested and ACCESSLIST is not empty (other clients have access),
     add requesting client to WAITLIST (it's empty),
     send lock requests (internal flush variant) and return
     (we could give out the page with READ access and wait for a unlock request, but I think not)
  else
     (ACCESSLIST is empty or READ access is requested and only READ clients are on ACCESSLIST)
     if page is flagged INVALID, send m_o_data_error to this client and return
     add this client to WAITLIST (it's empty)
     unlock pager
     read the page with pager_read_page()
     relock pager
     if pager_read_page() returned an error, mark page with ERROR and call send_error_to_WAITLIST
     if no error, service_waitlist(deallocate=true) (read/write status supplied by filesystem), clear ERROR
\end{semiverbatim}
\end{frame}

\begin{comment}
\begin{frame}
\frametitle{What kind of bugs have I found?}
\begin{itemize}
\item failure to update pagemap entry
\item FLUSHING flag
\item DEAD NAME notifications
\item condition variable
\item weak refs
\end{itemize}
\end{frame}
\end{comment}

\begin{frame}
\frametitle{Difficulty tracking which clients have access}

% Because of the kernel's ability to proactively flush pages (unless PRECIOUS is specified),
% we can't be certain that a client on a page's ACCESSLIST actually possesses that page.
% All we know for sure is that a client not on ACCESSLIST does not possess the page.

% Examining the Mach kernel code for m_o_lock_request, we see that the kernel might block
% while looping over the pages (and unlocks the memory object while doing so), so for a
% multi-page lock request, we need to consider the possibility that part of the page range
% might be processed, then other kernel operations happen (including VM page operations)
% before the remaining part of the page range is processed and the lock request completes.


\begin{itemize}
\item five clients have read access to page 50 and are on its ACCESSLIST
\item pager\_flush is called on pages 0-100
\item page 50 flushes on client A
\item client A re-requests access to page 50, and it is supplied (ACCESSLIST doesn't change)
\item the flushes complete
\item only client A now has access to page 50 and should be alone on its ACCESSLIST
\end{itemize}

% This scenario shows that ACCESSLIST, WAITLIST and a FLUSHING flag aren't enough; we have to track
% which clients requested access during the flush to correctly compute ACCESSLIST at the end.

\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt \_\_pthread\_cond\_timedwait\_internal}}
\begin{semiverbatim}
\tiny
  /* Block the thread.  */
  err = __pthread_timedblock (self, abstime, clock_id);

  __pthread_spin_lock (&cond->__lock);
  if (! self->prevp)
    \{
      /* Another thread removed us from the list of waiters, which means a
         wakeup message has been sent.  It was either consumed while we were
         blocking, or queued after we timed out and before we acquired the
         condition lock, in which case the message queue must be drained.  */
      if (! err)
        drain = 0;
      else
        \{
          assert (err == ETIMEDOUT);
          drain = 1;
        \}
    \}
  else
    \{
      /* We're still in the list of waiters.  Noone attempted to wake us up,
         i.e. we timed out.  */
      assert (err == ETIMEDOUT);
      __pthread_dequeue (self);
      drain = 0;
    \}
  __pthread_spin_unlock (&cond->__lock);
\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Original {\tt get\_identity} code}
\begin{semiverbatim}
\tiny
id_clean (void *cookie)
\{
  struct idspec *i = cookie;
  pthread_mutex_lock (&idlock);
  if (refcounts_hard_references(&i->pi.refcounts) == 0) \{
      /* Nobody got a send right in between, we can remove from the hash.  */
      hurd_ihash_locp_remove (&idhash, i->id_hashloc);
      ports_port_deref_weak (&i->pi);
  \}
  pthread_mutex_unlock (&idlock);
\}

fshelp_get_identity (struct port_bucket *bucket, ino_t fileno, mach_port_t *pt)
\{
  pthread_mutex_lock (&idlock);

  i = hurd_ihash_find (&idhash, (hurd_ihash_key_t) fileno);
  if (i == NULL) \{
      ports_create_port (idclass, bucket, sizeof (struct idspec), &i);
      hurd_ihash_add (&idhash, (hurd_ihash_key_t) fileno, i);

      /* Weak reference for the hash entry.  */
      ports_port_ref_weak(&i->pi);

      *pt = ports_get_right (i);
      ports_port_deref (i);
  \} else \{
    *pt = ports_get_right (i);
  \}

  pthread_mutex_unlock (&idlock);
\}

\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\tt libports} dereference code}
\begin{semiverbatim}
\tiny
void
ports_port_deref (void *portstruct)
\{
  struct port_info *pi = portstruct;
  struct references result;

  if (pi->class->dropweak_routine)
    \{
      /* If we need to call the dropweak routine, we need to hold one
         reference while doing so.  We use a weak reference for this
         purpose, which we acquire by demoting our hard reference to a
         weak one.  */
      refcounts_demote (&pi->refcounts, &result);

      if (result.hard == 0 && result.weak > 1)
        (*pi->class->dropweak_routine) (pi);

      refcounts_deref_weak (&pi->refcounts, &result);
    \}
  else
    refcounts_deref (&pi->refcounts, &result);

  if (result.hard == 0 && result.weak == 0)
    _ports_complete_deallocate (pi);
\}

\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{First attempt to fix {\tt get\_identity} code}
\begin{semiverbatim}
\tiny
id_drop_weak (void *cookie)
\{
  struct idspec *i = cookie;
  pthread_mutex_lock (&idlock);
  if (refcounts_hard_references(&i->pi.refcounts) == 0) \{
      /* Nobody got a send right in between, we can remove from the hash.  */
      hurd_ihash_locp_remove (&idhash, i->id_hashloc);
      ports_port_deref_weak (&i->pi);
  \}
  pthread_mutex_unlock (&idlock);
\}

fshelp_get_identity (struct port_bucket *bucket, ino_t fileno, mach_port_t *pt)
\{
  pthread_mutex_lock (&idlock);

  i = hurd_ihash_find (&idhash, (hurd_ihash_key_t) fileno);
  if (i == NULL) \{
      ports_create_port (idclass, bucket, sizeof (struct idspec), &i);
      hurd_ihash_add (&idhash, (hurd_ihash_key_t) fileno, i);

      /* Weak reference for the hash entry.  */
      ports_port_ref_weak(&i->pi);

      *pt = ports_get_right (i);
      ports_port_deref (i);
  \} else \{
    *pt = ports_get_right (i);
  \}

  pthread_mutex_unlock (&idlock);
\}

\end{semiverbatim}
\end{frame}

\begin{frame}[fragile]
\frametitle{Correctly fixed {\tt get\_identity} code}
\begin{semiverbatim}
\tiny
id_drop_weak (void *cookie)
\{
  struct idspec *i = cookie;
  pthread_mutex_lock (&idlock);
  if (refcounts_hard_references(&i->pi.refcounts) == 0 && i->id_hashloc != NULL) \{
      /* Nobody got a send right in between, we can remove i from the hash.  */
      hurd_ihash_locp_remove (&idhash, i->id_hashloc);
      i->id_hashloc = NULL;
      ports_port_deref_weak (&i->pi);
  \}
  pthread_mutex_unlock (&idlock);
\}

fshelp_get_identity (struct port_bucket *bucket, ino_t fileno, mach_port_t *pt)
\{
  pthread_mutex_lock (&idlock);

  i = hurd_ihash_find (&idhash, (hurd_ihash_key_t) fileno);
  if (i == NULL) \{
      ports_create_port (idclass, bucket, sizeof (struct idspec), &i);
      hurd_ihash_add (&idhash, (hurd_ihash_key_t) fileno, i);

      /* Weak reference for the hash entry.  */
      ports_port_ref_weak(&i->pi);

      *pt = ports_get_right (i);
      ports_port_deref (i);
  \} else \{
    *pt = ports_get_right (i);
  \}

  pthread_mutex_unlock (&idlock);
\}

\end{semiverbatim}
\end{frame}

\begin{frame}
\frametitle{Work Needed / Help Wanted}
\begin{itemize}
\item Finish multi-client {\tt libpager}
\item 64-bit user space
\item Multiprocessor support
\item Rewrite of {\tt netmsg}
\begin{itemize}
\item UDP or raw Ethernet frames instead of TCP
\item OSPF-like protocol to manage port numbers over multiple hosts
\item Synchronization of port closures (DEAD NAMES and NO SENDERS)
\item raw PCI device access
\end{itemize}
\vskip 0.5in
\item {\tt https://www.gnu.org/software/hurd/}
\item {\tt https://github.com/BrentBaccala/hurd}
\end{itemize}
\end{frame}

% https://events.ccc.de/congress/2007/Fahrplan/attachments/986_inside_the_mac_osx_kernel.pdf

% Mac OS X Internals: A Systems Approach

\end{document}
